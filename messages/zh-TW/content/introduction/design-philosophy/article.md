# 設計哲學

Intor 以 **避免黑盒行為以及不必要的系統侵入性** 為核心設計原則，
致力於在各種執行環境中維持一致、可檢視且可推理的翻譯核心。

> 多數 i18n 解法依賴大量設定與框架耦合，其黑盒化的翻譯流程缺乏可推理性與穩定性。

Intor 的設計由數個職責明確的核心組成，各層之間具有清楚的責任邊界，且不相互耦合。

---

## 語意設定模型 (Intor Config)

> Intor 將設定視為 **靜態的語意輸入**，而非 instance

每一份設定僅描述翻譯語意本身，不依賴執行環境、不承載行為邏輯，並明確定義其作用範圍；  
因此，每個 config 皆代表一個獨立的 i18n domain，而非 global singleton。

在此模型下，翻譯能力會依據執行上下文進行組裝，並使系統具備：

- 多組 i18n 並存
- 跨不同執行環境的一致行為
- 避免隱性全域狀態，維持翻譯行為的可推理性

此模型可於 build-time（如 CLI、CI/CD、SSG）與 runtime 中成立，並於不同時機使用相同的語意設定。

> 不採用 global singleton 意味著翻譯相關能力需於對應的執行階段顯式傳遞。

---

## 翻譯流程與責任邊界

翻譯行為的最底層被獨立為純粹的語意引擎 `intor-translator`，  
僅負責翻譯語意本身，不感知執行環境、框架或生命週期。

Intor 本體則負責在不同執行環境中收集並整理翻譯所需的上下文，再將其交由翻譯核心處理後輸出結果。  
整體流程刻意保持單向且可理解：

> 外部執行環境 → Intor 組裝上下文 → intor-translator 翻譯 → Intor 輸出
